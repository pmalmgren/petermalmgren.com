<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Home on Peter Malmgren</title>
    <link>https://petermalmgren.com/</link>
    <description>Recent content in Home on Peter Malmgren</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Mar 2023 07:53:41 -0500</lastBuildDate><atom:link href="https://petermalmgren.com/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Notes on Biscuits for Authentication</title>
      <link>https://petermalmgren.com/biscuitsec-0/</link>
      <pubDate>Wed, 08 Mar 2023 07:53:41 -0500</pubDate>
      
      <guid>https://petermalmgren.com/biscuitsec-0/</guid>
      <description>What are biscuits? Biscuits are a way to implement authorization tokens, such as API tokens, OAuth access tokens, and session ID cookie values.
Important Concepts &amp;amp; Terminology Authentication is the process of verifying that someone is who they say they are Authorization is the process of verifying that a token has access to do some operation on a resource Proof of possession is a process to prove that someone is in possession of a private key Delegation is a way to give someone else access to act on your behalf in an authorization systems, either implicitly via a bearer token, or explicitly via attenuation Attenuation is the process of adding a restriction to a token to support delegation Bearer tokens are credentials which grant access to resources, delegating the authority associated with them to the holder of the token Sessions are some proof that a a user has authenticated, and are usually stored or identified by a cookie Centralized or stateful authentication is a system of authentication that relies in a bearer token and some database to verify that a token is valid Decentralized or stateless authentication is a system of authentication that relies on cryptography to verify that a token is valid Comparisons Biscuits vs JWTs Biscuits are similar to JWTs in that they carry context about who is making the request and use public key cryptography for token verification.</description>
    </item>
    
    <item>
      <title>Getting data in and out of WASI modules</title>
      <link>https://petermalmgren.com/serverside-wasm-data/</link>
      <pubDate>Sun, 17 Apr 2022 08:56:08 -0400</pubDate>
      
      <guid>https://petermalmgren.com/serverside-wasm-data/</guid>
      <description>The problem After learning about WebAssembly, I kept running into a problem: Getting data in and out of WebAssembly, specifically server-side WebAssembly run with wasmtime, can be really hard.
Even though there are lots of examples of how to do this on the web, most of them focus specifically on JS and browser contexts. Here Iâ€™m going to focus on server-side WebAssembly, and in particular WebAssembly modules compiled into WebAssembly System Interface, or WASI.</description>
    </item>
    
    <item>
      <title>Cool things I learned about Bash this week</title>
      <link>https://petermalmgren.com/bash-things-i-learned/</link>
      <pubDate>Wed, 02 Jun 2021 09:15:03 -0400</pubDate>
      
      <guid>https://petermalmgren.com/bash-things-i-learned/</guid>
      <description>What is a shell? Bash is a kind of program called a shell. Shells are usually text-based, and allow us to interact with our computers by exposing a set of builtin functions for things like directory and file navigation, and run commands. The first Unix shell was called the Thompson shell and was written in 1971. Shells have come a long way since then, but more modern shells, including Bash, still use a bunch of the same ideas and concepts as this original shell that was written almost 50 years ago.</description>
    </item>
    
    <item>
      <title>Implementing a calculator parser in Rust</title>
      <link>https://petermalmgren.com/three-rust-parsers/</link>
      <pubDate>Tue, 01 Jun 2021 08:00:00 -0400</pubDate>
      
      <guid>https://petermalmgren.com/three-rust-parsers/</guid>
      <description>Motivation Parsing is something that I have really struggled with over the past few weeks. And because I&amp;rsquo;ve been struggling with it, I&amp;rsquo;ve also been avoiding working on it.
For these reasons, it has been hard for me to get up the motivation to work on and understand how parsing algorithms work. But this week I sat through my discomfort long enough to finally understand some of the algorithms and techniques for building a parser.</description>
    </item>
    
    <item>
      <title>Five problems in five weeks</title>
      <link>https://petermalmgren.com/five-weeks-five-problems/</link>
      <pubDate>Sat, 22 May 2021 08:16:23 -0400</pubDate>
      
      <guid>https://petermalmgren.com/five-weeks-five-problems/</guid>
      <description>Prioritization means saying no The hardest part about being at the Recurse Center has been prioritizing what I want to work on, and not feeling bad about myself when I fall short of my goals. My goals are always way too lofty and ambitious.
Even though I recognize that I can be too ambitious with my goals, I still want to push myself to some degree, and complete the last half of my batch with a sense of accomplishment.</description>
    </item>
    
    <item>
      <title>Creating a Token Scanner With Rust</title>
      <link>https://petermalmgren.com/token-scanning-with-rust/</link>
      <pubDate>Mon, 03 May 2021 07:29:21 -0400</pubDate>
      
      <guid>https://petermalmgren.com/token-scanning-with-rust/</guid>
      <description>What is a token scanner? A token scanner takes a character stream and turns it into a stream of tokens, which are valid characters or character combinations for a given programming language.
I&amp;rsquo;ve been going through Crafting Interpreters course using Rust instead of Java. Part of the course is implementing a token scanner for the Lox language.
While I was reading the chapter, I was more or less translating the Java version into Rust.</description>
    </item>
    
    <item>
      <title>How I Find Things in the Linux Kernel</title>
      <link>https://petermalmgren.com/tracing-linux-kernel-bpftrace/</link>
      <pubDate>Fri, 23 Apr 2021 08:56:08 -0400</pubDate>
      
      <guid>https://petermalmgren.com/tracing-linux-kernel-bpftrace/</guid>
      <description>Why dive into the Linux source code? Here are a few of reasons I&amp;rsquo;ve chosen to read the Linux source:
Curiosity, ex. what happens when you make an open() system call Debugging an issue which may be caused by a kernel bug, or strange kernel behavior Performance at the system level, ex. answering questions like: Where in the Linux kernel is my code calling into and spending the most time? I think it&amp;rsquo;s fun :) I&amp;rsquo;ve felt a bit intimidated in the past by opening up the Linux source tree and reading through the code.</description>
    </item>
    
    <item>
      <title>Implementing Tracepath in Rust</title>
      <link>https://petermalmgren.com/rust-tracepath/</link>
      <pubDate>Thu, 22 Apr 2021 08:03:02 -0400</pubDate>
      
      <guid>https://petermalmgren.com/rust-tracepath/</guid>
      <description>What is tracepath? Every time you send data over the Internet, it passes through a series of routers. Routers are network devices which know how to get packets to their destinations.
Tracepath is a Linux program which tells you about every router a packet has to go through to get to a host. The output looks something like this:
$ tracepath google.com -n 10 1?: [LOCALHOST] pmtu 1500 1: _gateway 6.</description>
    </item>
    
    <item>
      <title>Configuring Vim for Rust Development</title>
      <link>https://petermalmgren.com/rc-batch-day-9/</link>
      <pubDate>Thu, 08 Apr 2021 07:20:01 -0400</pubDate>
      
      <guid>https://petermalmgren.com/rc-batch-day-9/</guid>
      <description>Here&amp;rsquo;s how I set up neovim to work with rust-analyzer using ALE.
Basic setup: ALE and Syntax Highlighting ALE stands for &amp;ldquo;Asynchronous Lint Engine&amp;rdquo; and acts as a language server client for Vim and Neovim. I like it because it eliminates the need to set up different plugins for every language you use. It can do things like:
Autocomplete Fixing (formatting, whitespace/trailing newline removal) Linting Go to definition I also installed rust-lang/rust.</description>
    </item>
    
    <item>
      <title>Day 5: More macros</title>
      <link>https://petermalmgren.com/rc-batch-day-5/</link>
      <pubDate>Fri, 02 Apr 2021 07:20:01 -0400</pubDate>
      
      <guid>https://petermalmgren.com/rc-batch-day-5/</guid>
      <description>Where I left off Yesterday I wrapped up my day with some almost working code to implement a for..in loop in Racket. It compiled and kind of did what I set out to do, but not quite.
Today I&amp;rsquo;ll be diving into understand exactly how this code works, and what I can do to fix the problem with the &#39;(#&amp;lt;void&amp;gt; #&amp;lt;void&amp;gt; #&amp;lt;void&amp;gt; #&amp;lt;void&amp;gt;) being returned after it runs.
#lang racket (define-syntax for (syntax-rules (in) ; needed to match against for in [(for item in list body .</description>
    </item>
    
  </channel>
</rss>
